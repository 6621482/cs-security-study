# GDB (plugin = pwndbg) 

## GDB 기초 사용 방법
- `gdb`
  - 터미널에서 `gdb` 입력하면 GDB를 실행할 수 있음
  - 실행되면 `pwndbg`라고 뜸 
### 파일 불러오기 
- `file <바이너리경로>`
  - 바이너리 : CPU가 직접 실행할 수 있도록 컴파일된 실행 파일
  
### 실행 흐름 제어하기
- `run [프로그램 인자]` 또는 `r [프로그램 인자]`
  - 프로그램을 실행하는 명령어
  - 프로그램을 처음부터 다시 시작함 (브레이크 포인트는 유지)
  - run func1 은 func1을 실행한다는 의미가 아님에 주의할 것 
- `break <함수 이름>` 또는 `break *<주소>` (break 대신 b 사용 가능) 
  - 특정 주소에 중단점을 설정하는 명령어
  - CPU가 그 주소의 명령어를 실행하기 직전에 멈춤
  - 인자로 함수 이름을 전달한 경우 : 함수의 시작 주소에서 멈춤 (call 지점 아님)
- `continue [숫자]` 또는 `c [숫자]` 
  - 중단된 프로그램을 계속 실행시키는 명령어
  - 현재 멈춘 위치부터 실행을 재개함 
  - 현재 위치의 중단점을 [숫자]번 건너뛰고 그 다음 중단점에 도달했을 때 멈춤
- `entry`
  - 진입점부터 프로그램을 분석할 수 있게 해주는 명령어
    - 진입점(Entry Point) : OS가 프로그램을 시작할 때 처음 실행하는 주소
    - entry -> 런타임 초기화 코드 -> main 
- `start`
  - 프로그램을 실행해서 main 함수 시작 직전에 멈추게 하는 명령어
  - 자동으로 main에 브레이크포인트를 설정해서 main 함수의 첫 줄 실행 직전에 멈춤
  
### 실행 흐름 추적하기
- `ni`
  - next instruction 
  - 어셈블리 명령어를 한 줄 실행하는 명령어 
  - `call` 등을 통해 함수를 호출하는 경우 ni는 함수의 내부로 들어가지 않음 (함수 내부 통째로 실행한 후 다음 명령어 실행 직전에 멈춤) 
- `si`
  - step into
  - 어셈블리 명령어를 한 줄 실행하는 명령어 
  - `call` 등을 통해 함수를 호출하는 경우 si는 함수의 내부로 들어감 (함수 내부 첫 명령어 실행 직전에 멈춤) 
- `finish`
  - 지금 들어와 있는 함수의 끝까지 한 번에 실행하는 명령어

## 디버깅을 위해 자주 사용하는 명령어들 
- `info`
  - `info registers <레지스터명>` 또는 `i r <레지스터명>` 
    - 프로그램이 실행 중일 때 사용할 수 있는 명령어로, 레지스터에 저장된 값을 출력함
    - 참고 : 레지스터에 들어있는 값을 바로 사용하고 싶은 경우 `$<레지스터명>` 형식으로 사용 가능
  - `info breakpoints` 또는 `i b`
    - `break`명령어로 설정한 중단점을 확인할 수 있는 명령어
- `disable [중단점 번호]`
  - 중단점을 비활성화하는 명령어
- `enable [중단점 번호]`
  - 중단점을 활성화하는 명령어
- `delete [중단점 번호]` 또는 `d [중단점 번호]`
  - 중단점을 삭제하는 명령어
- `disassemble [함수이름 or 특정 주소 or 주소 범위]` 또는 `disass [함수이름 or 특정 주소 or 주소 범위]`
  - 현재 실행 위치가 속한 함수의 시작부터 끝까지를 디스어셈블하는 명령어
  - 인자를 전달하면 그 주소가 속한 함수 전체를 디스어셈블함
  - 그 외 디스어셈블 명령어(가독성 좋게 출력) : `u`, `nearpc`, `pdisass`
- `x/<포맷 및 크기>` 또는 `x/<개수><포맷 및 크기>` (e<mark>x</mark>amine)
  - 특정 주소에서 원하는 길이만큼의 데이터를 원하는 형식으로 인코딩하여 볼 수 있게 해주는 명령어
  - 포맷
    | 기호 | 의미 |
    |---|---|
    | `x` | 16진수 |
    | `o` | 8진수 |
    | `d` | 10진수 |
    | `u` | 부호 없는 10진수 |
    | `t` | 2진수 |
    | `f` | float 형 |
    | `a` | 주소 |
    | `i` | 명령어 |
    | `c` | 문자 |
    | `s` | 문자열 |
  - 크기
    | 기호 | 의미 |
    |---|---|
    | `b` | byte (1 byte) |
    | `h` | halfword (2 byte) |
    | `w` | word (4 byte) |
    | `g` | giant (8 byte) |
  - 예시
    - `x/5gx $rsp` : rsp부터 40바이트를 8바이트씩 Hex 형식으로 출력
    - `x/10i $rip` : rip부터 10줄의 어셈블리 명령어 출력
    - `x/s 0x404040` : 특정 주소의 문자열 출력
- `telescope <주소>`
  - 특정 주소의 메모리 값과 메모리가 참조하고 있는 주소를 재귀적으로 탐색하여 값을 보여줌
  - 가장 많이 쓰는 예시 : `telescope $rsp` (스택 보기)
- `vmmap`
  - 가상 메모리의 레이아웃을 보여주는 명령어
  - 현재 디버깅 중인 프로세스가 어떤 가상 메모리 영역을 어디 주소에, 어떤 권한으로 사용 중인지를 전부 출력함
- `backtrace` 또는 `bt` 
  - 콜 스택(Call Stack)을 확인하는 명령어
    - 콜 스택 : 프로그램이 실행되는 동안 함수가 호출되는 순서를 저장하는 구조
- `dump memory <파일명> <시작주소> <끝주소>`
  - 프로세스의 메모리 상태를 파일로 저장할 때 사용하는 명령어
- `context` 또는 `ctx`
  - 레지스터, 코드, 스택, 백트레이스를 동시에 보여주는 명령어
  - 프로그램이 실행되다가 중단점에 도달하면 자동으로 실행됨 
  - 4개의 영역으로 구분됨
    - `REGISTERS` : 레지스터의 상태를 보여줌
    - `DISAM` : rip부터 여러 줄에 걸쳐 디스어셈블된 결과를 보여줌
    - `STACK` : rsp부터 여러 줄에 걸쳐 스택의 값들을 보여줌
    - `BACKTRACE` : 현재 rip에 도달할 때까지 어떤 함수들이 중첩되어 호출됐는지 보여줌

- `set <주소/레지스터> = <변경할 값>`
  - 프로세스의 메모리 상태를 변경할 수 있는 명령어
  - 주로 레지스터 값을 변경하거나 특정 주소의 메모리값을 변경하기 위해 사용
  - ex. `set $rax = 0`, `set $rsp = $rbp`
  - 특정 주소의 값을 바꾸기 위해서는 자료형이 필요함 (C언어 스타일 자료형)
    - 형식 : `set *(자료형*)주소 = 값`
    - ex. `set *(unsigned int*)0x404040 = 10` : 0x404040 주소부터 시작해서 4바이트의 메모리 공간에 10을 기록 
