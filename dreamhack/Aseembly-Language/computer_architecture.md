# Computer Architecture

## Computer Architecture
- **Computer Architecture** : CPU, 메모리, 입출력 장치와 같은 하드웨어 구성 요소가 어떻게 설계되고 상호작용하는지를 연구하는 학문
  - 폰 노이만 구조
  - 하버드 구조
  - 수정된 하버드 구조
- **ISA** (Instruction Set Architecture) : CPU가 이해하고 실행할 수 있는 명령어 집합과 해당 명령어들의 동작 방식을 정의한 규약
  - ARM
  - MIPS
  - AVR
  - x86, x86-64
- **Micro Architecture** : CPU가 명령어 집합 구조(ISA)를 어떻게 효율적으로 구현하고 실행할지 CPU의 회로를 설계하는 분야
  - 캐시 설계
  - 파이프라이닝
  - 슈퍼 스칼라

### 폰 노이만 구조 (Von Neumann Architecture)
- 폰 노이만이 제안한 컴퓨터 구조
- 컴퓨터의 핵심 기능을 **연산, 제어, 저장**으로 구분

- 핵심 구성 요소
  - **CPU**(Central Processing Unit) : 컴퓨터 시스템의 모든 장치를 제어하고, 데이터를 처리(연산)하는 핵심 장치
    - 순차적으로 Fetch -> Decode -> Execute를 반복함
      - Fetch : 메모리에서 다음에 실행할 명령어를 가져옴
      - Decode : 가져온 명령어를 해석하여 어떤 동작을 할지 결정
      - Execute : 해석된 명령어에 따라 연산을 수행하고 결과를 저장함 
    - 내부 구성 요소
      - ALU(Arithmetic Logic Unit) : 산술 연산, 논리 연산 수행
      - Register : CPU 내부의 가장 빠른 저장공간으로 연산에 필요한 데이터, 주소, 중간 결과 등을 임시로 저장함
      - CU(Control Unit) : 명령어를 해석하고 ALU, 레지스터, 메모리 등에 제어신호를 전달함 (CPU 전체 동작을 제어)
      - Cache : 메모리 접근 지연을 줄이기 위한 고속 메모리로 자주 사용하는 데이터를 미리 저장함
    - CPU = 연산(ALU) + 제어(CU) + 임시 저장(Register, Cache)
  - **기억 장치** : 컴퓨터가 동작하는 데 필요한 데이터와 프로그램을 저장하기 위한 장치
    - 주기억장치 : 프로그램 실행 중 필요한 데이터를 임시 저장
      - CPU가 직접 접근 가능
      - 휘발성, 빠른 속도
      - RAM
    - 보조기억장치 : 데이터를 장기간 저장
      - CPU가 직접 접근하지 않고, 메모리를 거쳐 사용
      - 비휘발성, 저장 용량 큼
      - HDD, SSD
  - **BUS** : 컴퓨터 부품과 부품 사이, 또는 컴퓨터와 외부 장치 사이에서 데이터와 제어 신호를 전달하는 전자적 통로
    - 데이터 버스 : 실제 데이터 이동
    - 주소 버스 : 메모리 주소 지정
    - 제어 버스 : 읽기/쓰기, 인터럽트 등의 제어 신호 전달

### 명령어 집합 구조
- ISA : CPU가 해석하고 실행할 수 있는 명령어들의 집합과 그 규칙
- 소프트웨어와 하드웨어 사이의 인터페이스
- 종류
  - **CISC**(Complex Instruction Set Computer) : 메모리 효율성에 초점을 맞춰 개발된 구조 
    - 철학 : 하드웨어(CPU)가 복잡한 일을 직접 처리하게 해서, 소프트웨어(컴파일러)의 부담을 줄이자
    - 특징
      - 가변 길이 명령어
      - 복잡한 명령어 지원
    - 장점 : 소프트웨어 코드가 짧아져 메모리를 적게 차지
    - 단점 : 명령어 하나를 실행하는 데 걸리는 시간이 제각각이라 성능을 일정하게 끌어올리기 어려움
    - 주요 활용 : PC, 서버
    - 대표 ISA : x86-64
  - **RISC**(Reduced Instruction Set Computer) : CISC의 복잡성을 줄이기 위해 개발된 구조
    - 철학 : 하드웨어는 단순하게 만들고, 자주 쓰이는 핵심 명령어만 빠르게 처리하자. 복잡한 건 소프트웨어가 조합해서 해결한다.
    - 특징
      - 명령어가 단순하고 종류가 적음
      - 명령어의 길이가 고정되어 있어 처리가 효율적 (32비트 혹은 64비트로 고정) 
      - 전력 소모가 적고 발열이 낮아 모바일 기기에 유리함
    - 장점 : 속도가 빠르고 전역 효율이 극대화됨
    - 단점 : 단순한 명령어를 여러 번 조합해야 하므로 소프트웨어(코드)의 양이 늘어남 
    - 주요 활용 : 스마트폰, 태플릿
    - 대표 ISA : ARM, MIPS, AVR
  - ISA가 다양한 이유 : 모든 컴퓨터가 동일한 연산 성능과 사용 환경을 요구하지 않기 때문
 
### x86-64 아키텍처
- WORD : CPU가 한 번에 처리할 수 있는 데이터의 크기
  - 레지스터 크기 : CPU 내부의 레지스터가 한 번에 저장할 수 있는 데이터의 양
  - ALU 연산 데이터 크기 : ALU에서 연산할 수 있는 데이터의 크기
  - 표현 가능한 주소의 크기(데이터의 크기) : 메모리(RAM)의 위치를 가리키는 주소의 범위
  - 버스의 대역폭 : CPU, 메모리, 다른 부품들 사이에서 한 번에 전송할 수 있는 데이터의 양
  - WORD가 크면 유리한 점
    - 가상 메모리 주소 공간이 확장됨
      - 32비트 아키텍처 : 최대 약 4GB의 가상 메모리 제공 가능
      - 64비트 아키텍처 : 이론상 약 16EB의 가상 메모리 제공 가능
    - 연산 효율성 및 속도 향상
    
  #### x86-64 아키텍처 : 레지스터
  - **범용 레지스터** : 데이터 연산을 위해 사용되는 레지스터 (64비트)
    - rax(Accumulator Register) : 함수의 반환 값
    - rbx(Base Register)
    - rcx(Counter Register) : 반복문의 반복 횟수, 각종 연산의 시행 횟수
    - rdx(Data Register)
    - rsi(Source Index) : 데이터를 옮길 때 원본을 가리키는 포인터
    - rdi(Destination Index) : 데이터를 옮길 때 목적지를 가리키는 포인터
    - rsp(Stack Pointer) : 사용 중인 스택의 위치를 가리키는 포인터
    - rbp(Stack Base Pointer) : 스택의 바닥을 가리키는 포인터
    - r8, r9, r10, r11, r12, r13, r14, r15
  - **세그먼트 레지스터** : 메모리를 세그먼트 단위로 접근하는 데 사용되는 특수 레지스터 (16비트)
    - 과거(16비트 CPU) : 작은 주소 공간을 확장하기 위한 장치 (세그먼트 + 오프셋)
      - CS(Code Segment) : 실행할 코드의 시작 주소
      - DS(Data Segment) : 프로그램에 지정된 데이터 영역의 시작 주소
      - SS(Stack Segment) : 스택 영역의 시작 주소
      - ES, FS, GS : 범용적인 용도로 사용 
    - 현재(64비트 CPU) : 레지스터 하나로 큰 주소도 가리킬 수 있기 때문에 주소 계산에는 거의 사용되지 않음
      - CS : 권한 관리(유저 모드, 커널 모드 확인 용)
      - FS : TLS나 운영체제 핵심 정보 저장
      - Gs : TLS나 CPU별 특정 정보 저장
  - **명령어 포인터 레지스터** : CPU가 어느 부분의 코드를 실행할지 가리키는 레지스터 (64비트)
    - rip
  - **플래그 레지스터** : CPU가 연산을 수행한 후 결과의 상태를 저장하는 특수 레지스터 (64비트) 
    - 특정 연산 후 조건을 판단하는 데 사용됨
    - CF(Carry Flag) : 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정됨
    - ZF(Zero Flag) : 연산의 결과가 0일 경우 설정됨
    - SF(Sign Flag) : 연산의 결과가 음수일 경우 설정됨
    - OF(Overflow Flag) : 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정됨 
  - **레지스터 호환**
    - 범용 레지스터
      | 16비트 | 32비트 | 64비트 |
      |---|---|---|
      | AX | EAX | RAX |
      | BX | EBX | RBX |
      | CX | ECX | RCX |
      | DX | EDX | RDX |
      | SI | ESI | RSI |
      | DI | EDI | RDI |
      | SP | ESP | RSP |
      | BP | EBP | RBP |
    - 명령어 포인터 레지스터
      | 16비트 | 32비트 | 64비트 |
      |---|---|---|
      | IP | EIP | RIP |  
    - 부분 레지스터 구조
      | 64비트 레지스터 | 32비트 (하위) | 16비트 (하위) | 8비트 (상위) | 8비트 (하위) |
      |---|---|---|---|---|
      | RAX | EAX | AX | AH | AL |
      | RBX | EBX | BX | BH | BL |
      | RCX | ECX | CX | CH | CL |
      | RDX | EDX | DX | DH | DL |
      | RSI | ESI | SI | - | - |
      | RDI | EDI | DI | - | - |
      | RSP | ESP | SP | - | - |
      | RBP | EBP | BP | - | - |
      - x64에서 EAX에 값을 쓰면 RAX의 상위 32비트는 자동으로 0으로 클리어됨 
     
