# Link

## 라이브러리
- **라이브러리(Library)** : 개발자들이 자주 쓰는 함수(`printf`, `scanf`, `malloc`)를 매번 새로 짜지 않도록 미리 모아둔 파일
- 여러 프로그램이 함수를 공유해서 쓸 수 있게 하여 개발 효율을 높임

## 링크 
### 링크 
- **링크(Link)** : 컴파일의 마지막 단계로, 프로그램이 호출한 함수와 실제 라이브러리에 있는 함수를 연결하는 과정
- **오브젝트 파일(Object file)** : C 소스 코드가 전처리 -> 컴파일 -> 어셈블 과정을 거치면 생성되는 파일 (ex. `.o`)
  - 리눅스에서는 **ELF** 형식
  - 기계어로 번역되어 실행 가능한 형식을 갖추고 있음
  - `puts`나 `printf` 같은 함수를 사용했다는 기록(심볼)은 남아있지만, 정작 그 함수가 무슨 동작을 하는지에 대한 구체적인 내용이 포함되어 있지 않기 때문
  - 어셈블 (어셈블리 코드 -> 기계어)
    ```
    $ gcc -c hello-world.c -o hello-world.o
    ```
  - 오브젝트 파일 안에 있는 심볼의 상태 확인
    ```
    $ readelf -s hello-world.o | grep puts
    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
    ```
    - `readelf -s` : elf 파일의 심볼 테이블 출력 / `hello-world.o` : 아직 링크되지 않은 오브젝트 파일 / `grep puts` : 심볼 중에서 puts만 필터링
    - 결과 해석
      | 필드                 | 값     | 의미                     |
      | ------------------ | ----- | ---------------------- |
      | `11:`              | 심볼 번호 | 심볼 테이블 인덱스             |
      | `0000000000000000` | 주소    | **주소 없음**              |    
      | `0`                | 크기    | 크기 정보 없음               |
      | `NOTYPE`           | 타입    | 함수/변수 구분 없음            |
      | `GLOBAL`           | 바인딩   | 전역 심볼                  |
      | `DEFAULT`          | 가시성   | 기본                     |
      | `UND`              | 섹션    | **Undefined (정의 안 됨)** |
      | `puts`             | 이름    | C 라이브러리 함수 `puts`      |
      - NOTYPE : 링크 전이라서 puts의 실제 구현을 본 적 없기 때문에 이게 함수인지 변수인지도 모
      - UND 의미 : 이 오브젝트 파일 안에는 puts의 실제 구현이 없음
      - 링크가 `hello-world.o  +  libc.so` 연결하면서 puts의 실제 주소를 채워 넣음

### 링크 후
```
$ gcc -o hello-world hello-world.c
$ readelf -s hello-world | grep puts
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)
    46: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@@GLIBC_2.2.5
$ ldd hello-world
        linux-vdso.so.1 (0x00007ffec3995000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fee37831000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fee37e24000)
```
- `gcc -o hello-world hello-world.c` (컴파일 + 링크)
  - 컴파일해서 실행 파일 `hello-world`를 생성함 (링크 성공한 상태)
- `readelf -s hello-world | grep puts` (실행 파일 안의 심볼 상태 확인)
  - 실행 파일 `hello-world` 안에 있는 심볼 테이블에서 puts라는 문자열이 포함된 줄만 필터링해서 보여줌 
  - 출력 결과 해석 
    | 항목             | 의미                 |
    | -------------- | ------------------ |
    | `FUNC`         | 이 심볼은 **함수**       |
    | `GLOBAL`       | 전역 심볼              |
    | `DEFAULT`      | 기본 가시성             |
    | `UND`          | **이 파일 안에는 정의 없음** |
    | `puts@GLIBC_…` | libc에 있는 puts 함수   |
- `ldd hello-world` (실행 시 사용할 라이브러리 목록 확인) 
  - 이 실행 파일이 실행될 때 어떤 공유 라이브러리들을 필요로 하는지 보여줌
  - 출력 결과 해석
    | 항목                     | 의미                           |
    | ---------------------- | ---------------------------- |
    | `linux-vdso.so.1`      | 커널이 제공하는 가상 라이브러리            |
    | `libc.so.6`            | C 표준 라이브러리 (puts가 여기 있음)     |
    | `ld-linux-x86-64.so.2` | **동적 로더** (실행 시 라이브러리 연결 담당) |

```
$ ld --verbose | grep SEARCH_DIR | tr -s ' ;' '\n'
SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu")
SEARCH_DIR("=/lib/x86_64-linux-gnu")
SEARCH_DIR("=/usr/lib/x86_64-linux-gnu")
SEARCH_DIR("=/usr/lib/x86_64-linux-gnu64")
SEARCH_DIR("=/usr/local/lib64")
SEARCH_DIR("=/lib64")
SEARCH_DIR("=/usr/lib64")
SEARCH_DIR("=/usr/local/lib")
SEARCH_DIR("=/lib")
SEARCH_DIR("=/usr/lib")
SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64")
SEARCH_DIR("=/usr/x86_64-linux-gnu/lib")
```
- `ld --verbose | grep SEARCH_DIR | tr -s ' ;' '\n'`
  - 링커가 라이브러리 파일의 기본 검색 경로를 출력하는 명령어
- 출력 결과 해석
  - 링커가 라이브러리 파일(= 함수의 실제 기계어 코드가 들어있는 파일)을 찾을 때 검사하는 디렉토리들
  - 우선순위 목록이므로 위에 나올수록 먼저 검색됨 
- gcc는 소스를 컴파일할 때 표준 라이브러리의 라이브러리 파일들을 모두 탐색함 
- 링크를 거치고 나면 프로그램에서 `puts`를 호출할 때, `puts`의 정의가 있는 libc에서 `puts`의 코드를 찾고, 해당 코드를 실행함 

### 라이브러리 링크와 종류
- **동적 링크(Dynamic Link)** : 라이브러리 코드는 실행 파일에 넣지 않고, 실행할 때 외부 파일을 불러서 쓰는 방식 
  - 실행 파일에는 라이브러리 함수의 심볼과 참조 정보만 포함시키고, 실제 라이브러리 코드와의 연결은 런타임에 수행하는 방식
  - 작동 방식
    - 빌드 과정 : 링커는 바이너리에 "이 함수는 libc.so에 있다"는 정보만 기록함 (실제 코드는 포함하지 X)
    - 실행 시점
      - 프로그램 실행 시 동적링커가 필요한 공유 라이브러리(`.so`)를 프로세스의 가상 메모리에 매핑
      - 함수 호출 시, 매핑된 라이브러리 영역에서 해당 함수의 실제 주소를 찾아 호출함
  - 특징
    - 실행 파일 크기가 작음 (참조 정보만 유지)
    - 메모리 효율이 높음 (라이브러리 메모리를 공유)
    - 함수의 실제 주소를 알아내기 위해 PLT, GOT 개념이 필요함
  - 코드 (동적 링크가 기본)
    ```
    gcc hello.c -o hello
    ```
- **정적 링크(Static Link)** : 필요한 라이브러리 코드를 실행 파일 안에 복사해서 붙여넣는 방식
  - 컴파일 타임에 링커가 프로그램이 사용하는 모든 라이브러리 함수의 코드를 실행 파일 내부에 직접 복사하여 포함시키는 방식
  - 작동 방식
    - 빌드 과정 : 링커는 정적 라이브러리 아카이브(`.a`)에서 필요한 오브젝트 코드를 추출하여, 대상 바이너리의 코드 영역에 병합
    - 실행 시점 : 바이너리 내부에 이미 함수의 기계어 코드가 존재하므로, 실행 시 외부 라이브러리를 참조하거나 탐색할 필요 없이 즉시 함수를 호출함 
  - 특징
    - 실행 파일 크기가 큼 (라이브러리 코드 포함)
    - 메모리 효율이 낮음
  - 코드
    ```
    gcc hello.c -o hello -static
    ```

 ### PLT & GOT
 - **PLT(Procedure Linkage Table)** : 외부 라이브러리 함수를 호출하기 위해 사용하는 중간 점프 테이블 
   - 프로그래머가 코드에서 printf를 호출하면, 실제로는 바로 라이브러리의 printf로 가는 것이 아니라 **printf@PLT**라는 PLT 내부의 함수를 먼저 호출함
   - PLT는 GOT를 참조하여 실제 주소로 점프하는 역할
- **GOT(Global Offset Table)** : 외부 함수의 실제 메로리 주소를 저장해 두는 테이블
  - 라이브러리 내에 있는 함수의 실제 메모리 주소를 저장함
  - 처음에는 비어있거나 PLT내부를 가리킴 (ex. `GOT[puts] = 아직 모르는 상태`)
  - 함수가 한 번 호출되어 주소를 찾으면 그 주소를 기록해둠 
- 동작 원리 : Lazy Binding
  - 첫 호출
    ```
    puts()
     ↓
    puts@plt
     ↓
    GOT[puts] (비어 있음)
     ↓
    동적 로더
     ↓
    libc의 puts 주소 발견
     ↓
    GOT[puts]에 저장
     ↓
    puts 실행

    ```
  - 두 번째 호출 이후
    ```
    puts()
     ↓
    puts@plt
     ↓
    GOT[puts] (주소 있음)
     ↓
    바로 libc puts 실행
    ```
<mark> 시스템 해킹의 관점에서 본 PLT & GOT
- GOT overwrite : GOT 엔트리에 임의의 값을 오버라이트하여 실행 흐름을 변조하는 공격 기법
  - 취약점의 원인 : 검증 부재 (PLT가 GOT를 참조하여 실행 흐름을 옮길 때, GOT에 저장된 값이 진짜 라이브러리 주소가 맞는지 검증하는 절차가 없음)
  - 공격 메커니즘
    - 취약점을 이용하여 타겟 함수의 GOT 엔트리에 저장된 주소 값을 공격자가 원하는 주소로 덮어씀
    - 프로그램이 원래대로 타겟 함수를 호출하면, PLT는 변조된 GOT 값을 참조하게 되어 공격자가 의도한 코드가 실행됨 
  
## 컴파일 단계
- **전처리(Pre-processing)** : 본격적으로 컴파일하기 전에 소스 코드를 정리하는 준비 단계
  - #include 헤더 파일을 소스 코드에 복사해서 붙여넣음
  - #define 매크로를 실제 값으로 치환
  - 주석을 모두 지움
  - 결과 : 순수한 C 코드만 남은 파일 (확장자 : `.i`)
- **컴파일(Compilation)** : C언어를 어셈블리어로 번역
  - 문법 검사를 수행
  - 결과 : 어셈블리 파일 (확장자 : `.s`)
- **어셈블(Assembly)** : 어셈블리어를 기계어로 번역
  - 기계어 코드로 변환하여 오브젝트 파일 생성
  - 아직 라이브러리 함수의 주소를 모르기 때문에 실행은 불가능함
  - 결과 : 오브젝트 파일 (확장자 : `.o`)
- **링크(Linking)** : 여러 개의 오브젝트 파일과 라이브러리를 합쳐서 최종 실행 파일을 만듦
  - 오브젝트 파일에 있떤 심볼을 실제 라이브러리 함수의 주소와 연결함
  - 결과 : 실행 가능한 바이너리 파일 (확장자: `.exe` 또는 확장자 없음)
   
