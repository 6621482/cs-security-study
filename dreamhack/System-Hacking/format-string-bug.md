# Format String Bug

## Format String Bug
- **Format String Bug(FSB)** : 포맷 스트링 함수를 잘못 사용하여 발생하는 버그
  - 포맷 스트링을 사용자가 직접 입력할 수 있으면 공격자는 레지스터와 스택을 읽을 수 있고 임의 주소 읽기 및 쓰기도 가능함 
- **Format String** : `%[parameter][flags][width][.precision][length][specifier]`
  - specifier : 인자를 어떻게 사용할지 지정함
    | 형식 지정자 | 설명 |
    |------------|------|
    | d | 부호 있는 10진수 정수 |
    | u | 부호 없는 10진수 정수 |
    | s | 문자열 |
    | x | 부호 없는 16진수 정수 |
    | n | 해당하는 위치의 인자에 현재까지 사용된 문자열의 길이를 저장 (값 출력 X) |
    | p | void형 포인터 |
  - width : 최소 너비를 지정함
    | 너비 지정자 | 설명 |
    |------------|------|
    | 정수 | 정수의 값만큼을 최소 너비로 지정합니다. |
    | * | 인자를 두 개 사용 <br>첫 인자의 값만큼을 최소 너비로 지정해 두 번째 인자를 출력 |
    - 치환되는 문자열이 이 값보다 짧을 경우, 공백 문자(`' '`)를 문자열 앞에 패딩해줌  
  - length : 출력하고자 하는 변수의 크기를 지정함
    | 길이 지정자 | 설명 |
    |------------|------|
    | hh | 해당 인자가 `char` 크기임을 나타냄 |
    | h | 해당 인자가 `short int` 크기임을 나타냄 |
    | l | 해당 인자가 `long int` 크기임을 나타냄 |
    | ll | 해당 인자가 `long long int` 크기임을 나타냄 |
    - d, n 등의 형식 지정자 앞에 쓰임
    - 정수 값을 출력하고 싶지만 변수가 int형이 아닌 경우에 주로 사용함
    - ex. char형을 정수 형태로 출력 : `%hhd`
  - parameter : 참조할 인자의 인덱스를 지정함 
    - `%[파라미터값]$d`처럼 값 뒤에 `$`문자를 붙여 표기
    - 특정 인덱스의 인자를 사용할 수 있음
    - 파라미터 값이 전달된 인자의 갯수의 범위 내인지 확인하지 않음

### FSB - Read 
- 레지스터 및 스택 읽기
  ```
  int main() {
  char format[0x100];
  
  printf("Format: ");
  scanf("%s", format);
  printf(format);
  
  return 0;
  }
  ```
  - format = `%p, %p, %p, %p, %p, %p, %p, %p`인 경우
    - 함수 호출 규약에 따라 rdi의 다음 인자인 **rsi, rdx, rcx, r8, r9, [rsp], [rsp+8], [rsp+0x10]** 이 출력됨
    - printf 함수는 인자 개수를 확인하지 않으므로, 실제로 인자가 넘어오지 않아도 호출 규약에 따라 인자를 참조함
      
- 임의 주소 읽기
  - 스택에 어떤 메모리의 주소값이 적혀있다면 ,해당 주소에 적혀있는 값을 파라미터 값을 활용해 읽어올 수 있음
  - 예시 : 읽어오고 싶은 값(문자열)이 `rsp + 8`위치에 저장되어 있으면?
    - 호출 규약에 따라, `%7$s`를 사용하면 출력할 수 있음

### FSB - Write
- 임의 주소 쓰기
  - 포맷 스트링에 임의의 주소를 넣고, `%[n]$n`의 형식 지정자를 사용하면 그 주소에 데이터를 쓸 수 있음 

### exploit 흐름 정리
목표 : 포맷 스트링 공격을 통해 특정 변수의 값을 바꾸는 것   
1. 목표 변수의 오프셋 구하기
   - 방법 1 (CLI) : `nm` 명령어 사용   
     `nm fsb_overwrite | grep <변수명>`
     - 출력되는 주소값이 바이너리 시작점으로부터의 오프셋
   - 방법 2 (GDB) : 바이너리를 실행한 후 계산  
       (1) `p &<변수명>`: 현재 메모리상 변수 주소 확인  
       (2) `vmmap`: 바이너리의 시작 주소(Base) 확인  
       (3) `p/x [변수 주소] - [Base 주소]` : 오프셋 계산
2. 취약점 지점 분석 및 기준점(leak) 찾기
   - 취약점이 발생하는 시점의 스택을 확인하여, 바이너리 주소를 담고 있는 위치를 찾음
   - 예시 : `printf(buf)`에서 취약점이 발생한다고 가정  
     - 중단점 설정 : `disass main`으로 `printf` 호출 위치를 찾고 브레이크포인트를 설정
       ```
       b *main+76
       r
       ```
     - 스택 전수 조사 : `RSP` 주변의 메모리를 출력함
       ```
       x/32gx $rsp  (스택을 8바이트씩 32개 출력)
       ```
     - 기준점 선정 : 출력된 주소들 중 `vmmap`으로 확인한 바이너리 주소 범위에 포함되는 값을 고름
       - ex. `0x555555555293` (이 값의 위치가 RSP+0x48임을 기억)
3. 기준점 오프셋 계산
   - 유출할 주소가 바이너리 시작점에서 얼마나 떨어져 있는지 고정값을 구함
   - 오프셋 구하기
     ```
     p/x [기준점 주소] - [Base 주소]
     ```
     - ex. `0x555555555293 - 0x555555554000 = 0x1293`
   - 수립된 공식 : $$\text{Binary Base} = \text{Leaked Address} - 0x1293$$
4. 포맷 스트링 인자 순서 확인
   - %p를 몇 번 써야 우리가 찜한 RSP+0x48 위치의 값을 읽을 수 있는지 확인
   - x86-64 규칙: 첫 6개 인자는 레지스터(RDI, RSI, RDX, RCX, R8, R9)를 쓰고, 7번째 인자부터 스택(RSP)을 참조함
   - 계산법
     - RSP는 6번째 인자 (rdi 포맷 스트링 제외한 순서)  
     - RSP+0x48은 8바이트 단위로 9번째 칸(0x48 / 8 = 9)임
     - 따라서 6 + 9 = 15번째 인자가 됨 -> `%15$p` 
5. exploit
   - 유출된 주소로 변수의 진짜 주소를 계산하고 `%n`을 이용해 값을 덮어씀
   - 실시간 주소 계산
     - `current_base = leak - 0x1293`
     - `target_addr = current_base + 목표변수_offset`
   - 값 덮어쓰기
     - `%[숫자]c%[인덱스]$n` 형식을 사용
     - `숫자` : 바꾸고싶은 숫자
     - `인덱스` : target_addr가 스택의 몇 번째에 위치하는지에 따라 결정 
