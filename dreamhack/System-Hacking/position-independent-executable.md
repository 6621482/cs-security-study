# PIE (Position-Independent-Executable)

## ALSR (Address Space Layout Randomization)
- 바이너리가 실행될 때마다 메모리의 특정 영역 주소를 무작위로 배치하는 기술
- 대상 : 스택(Stack), 힙(Heap), 공유 라이브러리(Shared Library) 등
- 효과 : 공격자가 system() 함수나 쉘코드의 정확한 주소를 미리 알 수 없게 만들어, 고정된 주소를 이용한 공격(예: Ret-to-Libc)을 어렵게 함
- 한계 : 일반적으로 실행 파일 자체의 코드 영역(Code/Text)이나 전역 변수 영역(Data/BSS)은 주소가 고정된 상태로 남음

## PIE 
- ASLR이 적용되지 않던 실행 파일이 매핑되는 영역까지 무작위 주소로 매핑되도록 하는 기술
  - 실행 파일이 매핑되는 영역 : 컴파일된 바이너리 파일의 내용이 그대로 메모리에 옮겨진 것
    - code 영역, data 영역, bss 영역 
- 실행 파일의 `main()` 함수 위치조차 매핑될 때마다 바뀌기 때문에, 바이너리 내부의 가젯이나 전역 변수를 이용하는 것이 훨씬 까다로워짐

## PIC
- 메모리의 어느 주소에 적재되어도 코드의 의미가 훼손되지 않고 실행될 수 있는 코드
- ELF 파일의 형태
  - 실행 파일 (Executable): addr와 같이 사용자가 직접 실행하는 일반적인 프로그램
  - 공유 오브젝트 (Shared Object, SO): libc.so와 같이 프로그램들이 공통으로 사용하는 라이브러리 파일 (재배치 가능하도록 설계됨)
- PIC가 필요한 이유
  - 공유 라이브러리는 여러 프로그램이 동시에 불러와서 사용함
  - 각 프로그램마다 메모리 상황이 다르기 때문에 라이브러리가 매번 같은 주소에 들어갈 수 없음
  - 어떤 주소에 위치하더라도 문제없이 동작해야 하기 때문에 PIC 기술이 필수적임
- 동작 원리
  - RIP를 기준으로 데이터를 상대 참조(Relative Addressing) 
  - CPU가 현재 실행 중인 코드의 주소를 기준으로 데이터의 위치를 계산함 (상대 주소)
- PIE : 무작위 주소에 매핑돼도 실행 가능한 실행 파일 (자체적으로 보호 기법은 아님) 
  - ASLR이 적용된 시스템에서는 실행 파일도 무작위 주소에 적재됨
  - ASLR이 적용되지 않은 시스템에서는 PIE가 적용된 바이너리라도 무작위 주소에 적재되지 않음

### PIC 우회
- 코드 베이스 구하기
  - 코드 베이스 = 메모리에 로드된 실행 파일의 첫 번째 주소
  - `코드 베이스 = 유출된 주소 - 오프셋`
  - 코드 베이스를 구하면 이를 기준으로 가젯이나 전역 변수의 실제 위치를 정확히 계산할 수 있음
- Partial Overwrite
  - 주소 전체를 알아내기 힘들 때, 주소의 일부 바이트만 덮어써서 실행 흐름을 조작하는 기법
  - ASLR이 적용되어도 페이지 단위로 매핑되기 때문에 주소의 하위 12비트 값은 항상 일정하게 유지됨
  - 공격 방식
    - 1바이트 조작 : 바꾸려는 대상 주소와 현재 주소의 차이가 마지막 1바이트 이내이면 무조건 성공함
    - 2바이트 이상 조작 : 하위 12비트를 제외한 나머지 부분은 랜덤하게 섞여 있으므로 맞출 때까지 반복해서 시도하는 브루트 포싱(Brute Forcing)이 필요함
  
     
## 추가 내용
**오프셋 확인하는 방법**   
- `readelf -s [파일명] | grep [함수명]`
  - readelf를 이용하여 바이너리 내부의 심볼 테이블을 볼 수 있음
  - 예시
    ```
    $ readelf -s addr | grep main
    62: 000000000000063a    43 FUNC    GLOBAL DEFAULT   13 main
    ```
    - `0x63a`가 main 함수의 오프셋
    - 바이너리가 메모리 어디에 로드되든, 시작 지점(Code Base)으로부터 0x63a만큼 떨어진 곳에 main이 있다는 의미
- gdb 디버거로 확인
  - `gdb [파일명]` 실행 후 `info functions` 또는 `p [함수명]` 입력
  - PIE 환경에서의 특징: PIE가 적용된 바이너리를 gdb로 열면, 실행 전 주소가 0x0부터 시작하는 작은 값으로 보임
  - 예시
    - main의 주소가 0x11d5로 보인다면, 오프셋은 0x11d5임 
- objdump로 확인
  - `objdump -d [파일명] | grep -A 5 [함수명]`
  - 특정 기계어 뭉치를 찾을 때 주로 사용 (가젯 찾을 때) 
  - 예시
    ```
    000000000000063a <main>:
     63a:   55                      push   %rbp
     63b:   48 89 e5                mov    %rsp,%rbp
    ```
    - 함수 이름 옆에 적힌 `0x63a`가 해당 함수의 시작 오프셋
