# ptmalloc

## ptmalloc
- **Memory Allocator** : 한정된 메모리 자원을 여러 프로세스에 효율적으로 배분하는 도구
  - 동적할당과 해제 : 프로세스 실행 중 필요한 만큼 메모리를 할당받고, 사용이 끝나면 반환
  - 종류
    - 리눅스 : ptmalloc2
    - 구글 : tcmalloc
    - 페이스북/파이어폭스 : jemalloc
### ptmalloc의 메모리 관리 전략 
- **메모리 낭비 방지**
  - 할당 요청이 발생하면, 먼저 해제된 메모리 공간 중에서 재사용할 수 있는 공간이 있는지 탐색함
  - 해제된 메모리 공간 중에서 요청된 크기와 같은 크기의 메모리 공간이 있다면 이를 재사용
  - 작은 크기의 할당 요청이 발생했을 때, 해제된 메모리 공간 중 큰 메모리 공간의 영역을 나누어 줌
- **빠른 메모리 재사용**
  - 메모리 공간을 해제할 때, tcache 또는 bin이라는 연결 리스트에 해제된 공간의 정보를 저장함
  - 각각은 서로 다른 크기의 메모리 공간을 저장함  
  - 특정 크기의 할당 요청이 발생했을 때, 그 크기와 관련된 저장소만 탐색
- **메모리 단편화 방지**
  - 내부 단편화 : 할당된 메모리 공간에 비해 실제 데이터가 차지하는 공간이 적어 메모리가 낭비되는 현상
  - 외부 단편화 : 할당된 공간들 사이에 틈새 공간들이 많아져서 생기는 비효율
  - ptmalloc이 단편화를 줄이는 방법
    - **정렬(Alignment)**
      - 64비트 환경에서 메모리를 16바이트 단위로 할당
      - 예시 : 사용자가 4바이트를 요청하면 16바이트를, 17바이트를 요청하면 32바이트를 할당
      - 약간의 내부 단편화는 발생할 수 있지만, 메모리 크기를 표준화함으로써 나중에 비슷한 크기의 요청이 왔을 때 재사용하기 유리해져 외부 단편화를 줄임
    - **병합(Coalescence)**
      - 특정 조건이 만족되면 해제된 인접한 메모리 공간들을 하나로 합쳐 더 큰 빈 공간으로 만듦
      - 잘게 나뉜 영역을 합쳐 큰 메모리 요청에도 대응할 수 있게 함
    - **분할(split)**
      - 큰 빈 공간이 있을 때, 사용자의 요청이 그보다 작으면 필요한 만큼만 쪼개서 할당하고 나머지는 다시 빈 공간으로 남겨둠
      - 큰 공간을 통째로 낭비하지 않고 필요한 만큼만 사용할 수 있음 
### ptmalloc의 객체
- **청크(Chunk)**
  - ptmalloc이 할당한 메모리 공간
  - 구조 : 헤더 + 데이터
    - 헤더 : 청크 관리에 필요한 정보
    - 데이터 : 사용자가 입력한 데이터
  - In-use & Freed
    ```
    < In-use >
    낮은 주소 (Low Address)
    +-------------------------------------------+
    |             prev_size (8-byte)            | <- 인접한 이전 청크가 Freed면 크기 저장
    +-------------------------------------------+
    |         size (8-byte)         | A | M | P | <- 현재 청크 크기 + 상태 플래그
    +-------------------------------------------+
    |                                           |
    |             User Data (data)              | <- 사용자가 실제로 쓰는 공간
    |                                           |
    +-------------------------------------------+
    높은 주소 (High Address)
    ```
    ```
    < Freed >
    낮은 주소 (Low Address)
    +-------------------------------------------+
    |             prev_size (8-byte)            |
    +-------------------------------------------+
    |         size (8-byte)         | A | M | P |
    +-------------------------------------------+
    |          fd (Forward Pointer)             | <- 다음 Freed 청크의 주소
    +-------------------------------------------+
    |         bk (Backward Pointer)             | <- 이전 Freed 청크의 주소
    +-------------------------------------------+
    |                                           |
    |            남은 데이터 영역 (data)          |
    |                                           |
    +-------------------------------------------+
    높은 주소 (High Address)
    ```
    - prev _size(8바이트) : 이전 청크가 해제된 경우에만 해당 청크의 크기가 저장됨
    - size(8바이트) : 청크의 전체 크기
      - 청크 헤더 크기 (16바이트) + 사용자가 요청한 크기 정렬한 값
    - flags(3비트) : allocated arena(A), mmap'd(M), prev-in-use(P) 
      - 64비트 환경에서 청크는 16바이트 단위로 할당되므로, size의 하위 4비트는 의미를 갖지 않음
      - size의 하위 3비트를 청크 관리에 필요한 플래그 값으로 사용
    - fd(8바이트) : 연결리스트에서 다음 청크를 가리킴
    - bk(8바이트) : 연결리스트에서 이전 청크를 기리킴

- **bin**
  - 사용이 끝난 청크들이 저장되는 객체
  - 메모리의 낭비를 막고, 해제된 청크를 빠르게 재사용할 수 있게 함
  - 총 128개의 bin이 정의되어 있음
    - smallbin(62개) + largebin(1개) + unsortedbin(1개) + not used(2개)

- **smallbin**
  - 대상 : 32바이트 이상 1024바이트 미만의 크기를 갖는 청크들이 보관됨 
  - 하나의 smallbin에는 같은 크기의 청크들만 보관됨
  - index가 증가하면 저장되는 청크들의 크기는 16바이트씩 커짐
    - smallbin[0] : 32바이트 청크 보관
    - smallbin[61] : 1024바이트 청크 보관
  - 구조 : 원형 이중 연결 리스트
  - 재할당 방식 : FIFO (먼저 해제된 청크가 먼저 재할당됨)
  - 운영 프로세스
    - unlink : 리스트에 청크를 추가하거나 꺼낼 때 연결 고리를 잠깐 끊고 다시 잇는 과정
    - consolidation : 메모리상에서 인접한 두 청크가 모두 해제되어 smallbin에 있을 경우, 이들을 합쳐 더 큰 빈 공간을 만듦 (외부 단편화를 줄일 수 있음)
   
- **fastbin**
  - 대상 : 32바이트 이상 176바이트 미만의 크기를 갖는 청크들이 보관됨
  - bin 개수 : 16바이트 단위로 총 10개
  - 하나의 fastbin에는 같은 크기의 청크들만 보관됨
  - 리눅스는 이 중에서 작은 크기부터 7개의 fastbin만 사용함 (32바이트 이상 128바이트 이하)
  - 구조 : 단일 연결리스트
    - 단일 연결리스트이므로 청크를 꺼낼 때 꺼낸 청크의 앞과 뒤를 연겨랗는 unlink 과정이 필요없음 
  - 재할당 방식 : LIFO (가장 나중에 해제된 청크가 먼저 재할당됨) -> 속도가 매우 빠르지만, 다른 방식에 비해 메모리 파편화가 심해질 수 있음
  - 효율성 중심 : 작은 청크들은 자주 할당되고 해제되기 때문에 파편화 관리보다 처리 속도에 우선 순위를 둠
  - 병합 불가 : fastbin에 저장된 청크들은 서로 인접해 있더라도 병합되지 않음
 
- **largebin**
  - 대상 : 1024바이트 이상의 크기를 갖는 청크들이 보관됨
  - bin 개수 : 총 63개
  - 하나의 largebin에서는 일정 범위 내의 다양한 크기를 가진 청크들을 보관함
    - 재할당 요청 발생 시 그 안에서 크기가 가장 비슷한 청크를 꺼내 재할당함
    - 탐색 속도를 높이기 위해 라지빈 내부의 청크들은 크기 내림차순으로 정렬되어 있음 
  - 인덱스가 커질수록 각 라지빈이 담당하는 크기의 범위가 로그적으로 증가함
    - largebin[0] : 1024바이트 이상 ~ 1088바이트 미만
  - 구조 : 이중 연결 리스트
  - 운영 프로세스
    - unlink
    - consolidation
   
- **unsortedbin**
  - 대상 : 아직 분류되지 않은 청크들이 보관됨
  - 전체 시스템에서 하나만 존재
  - fastbin에 들어가지 않는 모든 크기의 청크는 해제될 때 unsortedbin에 저장됨
  - 구조 : 원형 이중 연결 리스트 (내부 정렬 X)
    - 리스트에 아무것도 없으면 main_arena의 주소를 기록함 
  - 할당 프로세스
    - 탐색 순서
      - smallbin 크기 요청 : fastbin -> smallbin을 먼저 찾고, 없으면 unsorted bin을 탐색
      - largebin 크기 요청 : unsortedbin을 가장 먼저 탐색
    - 청크 분류
      - 탐색 과정에서 적절한 크기의 청크를 발견하면 즉시 반환하여 사용함
      - 사용되지 않고 남은 청크들은 각각 크기에 맞는 적절한 bin으로 재분류됨
  - 사용 이유
    - 즉시 재할당 유리 : 방금 해제된 청크와 비슷한 크기의 메모리 요청이 들어올 경우. 분류 과정을 거치지 않고 Unsorted Bin에서 즉시 꺼낼 수 있어 효율적임 
    - 분류 비용 절감 : 특히 Largebin의 경우, 크기순으로 정렬된 리스트에서 적절한 삽입 위치를 찾는 비용이 크므로 Unsorted Bin을 쓰면 이 과정을 뒤로 미루거나 생략할 수 있음
    - 연속 해제 시 효율: 여러 청크가 연속으로 해제될 때마다 매번 병합하고 재분류하는 반복적인 비용을 줄여줌

- **arena**
  - fastbin, smallbi, largebin 등의 정보를 모두 담고 있는 객체
  - 모든 스레드가 공유하는 자원
  - libc.so 파일의 데이터 영역에 main_arena 구조체가 정의되어 있음
    - main_arena의 주소를 알아냄 = libc.so 라이브러리의 특정 지점 주소를 알아냄 
  - 상태 표시 (A 플래그): 청크 헤더의 size 필드에 포함된 'A' 플래그는 해당 청크가 메인 아레나가 아닌 별도의 아레나에 속해 있는지 여부를 나타냄 
  - 멀티 스레드와 락 메커니즘
    - 레이스 컨디션 : 어떤 공유 자원에 여러 스레드가 동시에 접근할 때 발생하는 오동작
    - 락(Lock) 적용: 이를 막기 위해 한 스레드가 아레나에 접근할 때 락을 걸어 다른 스레드의 접근을 차단함
      - arena가 lock에 걸리면 다른 스레드는 기다려야 하므로 병목 현상이 발생함 
      - Deadlock : 여러 스레드가 서로 물리고 물려서 어떤 스레드도 락을 해제하지 못하는 상황 
  - 확장성
    - 사용하려는 arena에 lock이 걸려 있으면 ptmalloc은 새로운 arena를 생성하여 작업을 처리함
    - 성능 효율을 위해 arena의 개수는 최대 64개로 제한되어 있음

- **tcache**
  - 각 스레드에 독립적으로 할당되는 캐시 저장소
  - 구조 : 단일 연결 리스트
  - 동작 방식 : LIFO
  - 병합 불가 : tcache에 보관된 청크들은 서로 인접해 있어도 병합되지 않음
  - 저장 범위 및 개수
    - 32바이트 이상 1040바이트 이하의 청크를 보관함 
    - 스레드당 64개의 tcache bin을 가짐
    - 각 bin당 보관할 수 있는 청크의 개수 : 7개
  - 할당 및 해제 프로세스
    - 메모리 할당이나 해제 요청 시 ptmalloc은 tcache를 가장 먼저 조회
    - 메모리를 해제할 때 해당 크기의 tcache가 이미 가득 차 있으면, 청크는 적절한 일반 bin으로 분류됨
    - arena의 bin에 접근하기 전에 먼저 tcache를 사용하므로 아레나에서 발생할 수 있는 병목현상을 완화할 수 있음
  - 취약점 : 속도를 위해 보안 검사가 많이 생략되어 있어 heap exploit의 좋은 도구가 됨 

### free(chunk)
```
free(ptr)
 ↓
[1] 전처리 및 유효성 검사
 ↓
[2] tcache 처리
 ↓
[3] fastbin 처리
 ↓
[4] 청크 병합
 ↓
[5] unsorted bin 삽입
```
1. 전처리 및 유효성 검사
   - 전달된 포인터가 해제 가능한 지 검사
   - NULL 체크, size 검사
2. tache 처리
   - 대상 : 크기가 0x20 ~ 0x410 바이트 사이인 청크
   - 해당 크기의 tcache bin에 빈 자리가 있으면 바로 집어넣음
   - 병합을 하지 않으며, fd 자리에 다음 tcache 청크의 주소만 적음
3. fastbin 처리
   - tcache가 다 찼거나 크기가 작을 때 사용하는 보관함
   - main_arena의 fastbinY 배열에 청크를 넣음
   - 성능을 위해 인접한 청크가 비어있어도 병합하지 않음
4. 청크 병합
   - tache와 fastbin에 들어가지 못한 일반 청브들이 거치는 단계
   - 이전 청크와의 병합 : 현재 청크헤더의 PREV_INUSE 비트를 확인함
     - 비트가 0이면(이전 청크가 free 상태), 두 청크를 합쳐 더 큰 덩어리를 만듦
   - 다음 청크와의 병합 : 다음 청크가 현재 사용 중인지 확인함
     - 다음 청크가 top chunk라면 그냥 top chunk 속으로 흡수됨
     - 다음 청크가 일반 free 청크라면 합침
5. unsorted bin 삽입
   - 병합이 완료된(또는 병합할 게 없는) 청크는 unsorted bin에 삽입됨
   - 청크의 헤더에 있는 fd, bk 포인터에 main_arena의 특정 주소를 씀
   - 이중 연결 리스트로 관리함 
