## Dreamhack - basic_exploitation

### 문제 유형
- 시스템 해킹 기초
- 스택 기반 버퍼 오버플로우
- 쉘 코드 삽입
- 원격 서비스 exploit
- scanf("%s") 입력 제약 우회

### 문제 요약
프로그램에 스택에 buf를 할당하고, 시작할 때 buf의 주소를 출력해줌  
이후 scanf("%s", buf)로 입력을 받아 exploit을 통해 쉘을 획득해야 함  
*참고 : arch = i386-32-little

### 코드 분석 포인트
- 주소 leak
  - `printf("buf = (%p)\n", buf);`로 스택 버퍼 주소를 제공 -> ASLR이 있어도 주소를 알 수 있어 우회 가능
- 버퍼 크기와 오버플로우 가능성
  - 코드상 버퍼 크기 : 0x80 (128바이트) 
  - 입력 함수 : `scanf("%141s", buf);` (최대 141바이트 입력) -> 리턴 주소 덮어쓰기 가능 
- 스택 프레임 구조 (i386)
  - `buf(0x80)` → `saved EBP(4)` → `RET(4)`
  - ret을 buf 주소로 덮으면, buf 시작점에 넣어둔 쉘코드로 실행 흐름을 돌릴 수 있음 
- <mark>핵심 제약 : scanf 입력 종료 문자
  - `scanf("%s")`는 공백 문자(' ', \t, \n 등)를 만나면 입력을 즉시 중단함 
  - 쉘코드 바이트열 중간에 해당 바이트가 포함되면 페이로드가 잘려 exploit 실패 
 
### 접근 과정
1. 원격 출력에서 buf 주소 파싱 
   - `recvuntil(b"buf = ")`후 `recvline()`으로 주소 문자열 획득
   - `eval()`을 사용하여 정수형 주소로 변환
2. 쉘코드
   - 처음에는 `shellcraft.execve("/bin/sh", 0, 0)` + `asm()`을 사용하였음 -> 실패함 (중간에 공백 문자가 포함됨)
   - scanf 우회용 쉘코드를 사용해야 함 
3. 페이로드 구성
   - payload = shellcode + padding + buffer address
   - 패딩 길이: 0x80(버퍼) + 0x04(SFP) - len(shellcode)
4. 전송 및 쉘 획득
   - sendline(payload)로 전송 후 interactive()로 쉘 제어

### 어려웠던 점
- 계속 EOF 오류가 발생하였고, 원인을 몰랐음
  - ret address를 잘못 받은것인지, 쉘코드가 잘못된건인지 등
- scanf("%s") 제약을 몰랐음
  - read()처럼 바이트를 그대로 받는 줄 알았는데 scanf는 특정 문자를 만나면 입력이 끊김
  - 이에 따라 shallcraft 쉘코드가 실패함
- 출력이 `buf = (0x...)`로, 주소에 괄호가 포함되는 것을 놓침
  - eval()을 활용해야 함 (또는 슬라이싱) 

### 배운 점 
- 입력 함수(read, scanf, gets)의 특성에 따라 사용할 수 있는 쉘코드가 달라진다는 것을 알게 됨
- shellcraft를 사용하는 것도 좋지만, 스스로 쉘코드를 작성할수도 있어야 함 
- buf 주소를 leak 해주면 ASLR이 있어도 공격이 쉬워짐

### 쓰인 개념
- 스택 프레임 구조
- 버퍼 오버플로우
- 쉘코드 주입
- 엔디안 : p32()로 4비트 리틀엔디안 패킹
- pwntools
  - remote, recvuntil, recvline, sendline, interactive

### 추가 내용
**Q. scanf("%141s", buf)**
- `scanf("%s")`는 문자열 입력 함수
- 임의의 바이트를 받는 것이 아닌, 문자열 규칙을 따름
- 입력을 멈추는 조건
  - 공백(`' '`) : 0x20
  - 탭(`\t`) : 0x09
  - 개행(`\n`) : 0x0a
  - 수직 탭(`\v`) : 0x0b
  - 폼 피드(`\f`) : 0x0c
  - 캐리지 리턴(`\r`) : 0x0d 
- scanf는 지정한 길이만큼 무조건 읽는 함수가 아님
- payload 전체가 들어가기 전에 scanf 가 중간에서 입력을 끊을 수 있음

**Q. read(0, buf, 141)**
- whitespace 상관없이 정확하게 141바이트를 그대로 읽음
- shellcraft도 문제없이 사용할 수 있음

**Q. shellcraft()란 무엇인가?**
- pwntools가 제공하는 아키텍처, os 맞춤 쉘코드 생성기
- 직접 어셈블리를 쓰지 않아도 쉘 코드를 자동으로 만들어줌
- 예시
  ```
  context.arch = "amd64" (또는 "i386" 등)
  shellcode = shellcraft.execve("/bin/sh", 0, 0)
  shellcode = asm(shellcode)
  ```
  - 아키텍처 차이를 자동으로 처리해줌 (syscall 번호, 레지스터 사용 방식을 자동으로 분기해줌)

**Q. i386 (32-bit) vs amd64 (64-bit) syscall 번호 및 호출 방식 차이?**  
- i386
  - 호출 명령어 : `int 0x80`
  - syscall 번호 레지스터 : eax
  - 인자 레지스터(순서대로) : ebx, ecx, edx, esi, edi, ebp
  - 예시
    ```
    mov eax, SYS_execve
    mov ebx, filename
    mov ecx, argv
    mov edx, envp
    int 0x80
    ```
- amd64
  - 호출 명령어 : `syscall`
  - syscall 번호 레지스터 : rax
  - 인자 레지스터(순서대로) : rdi, rsi, rdx, r10, r8, r9
  - 예시
    ```
    mov rax, SYS_execve
    mov rdi, filename
    mov rsi, argv
    mov rdx, envp
    syscall
    ```
- 주요 syscall 번호 비교
  | syscall | i386 (32-bit) | amd64 (64-bit) |
  | ------- | ------------- | -------------- |
  | exit    | 1             | 60             |
  | read    | 3             | 0              |
  | write   | 4             | 1              |
  | open    | 5             | 2              |
  | close   | 6             | 3              |
  | execve  | **11 (0x0b)** | **59 (0x3b)**  |
  | mmap    | 90            | 9              |
  | brk     | 45            | 12             |

**Q. shellcraft 사용했을 때 에러 생긴 이유?**
- 문제 환경에서 execve 시스템 콜 번호 = 11 (0x0b)
- shellcraft.execve는 보통 mov al, 0xb 와 같은 명령어를 사용하여 기계어에 `\x0b`(수직 탭)가 포함됨
- scanf는 \x0b를 공백으로 인식하여 입력을 끊어버림 → EOFError 발생 원인

**Q. 우회 원리?**
- scanf가 허용하는 숫자 만으로 숫자 11을 만들어야 함
- `mov al, 0x8` (`\xb0\x08`): Backspace(0x08)는 공백 문자가 아니므로 입력 가능
- `inc eax` (`\x40`): 값을 1 증가시키는 명령어를 3번 반복
- 8 + 1 + 1 + 1 = 11(0x0b)을 레지스터에 저장할 수 있음
- 이 방식으로 \x0b 바이트 없이 시스템 콜을 호출함
