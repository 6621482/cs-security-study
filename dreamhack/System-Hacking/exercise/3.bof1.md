## Dreamhack - Return Address Overwrite 

### 문제 유형
- 스택 기반 버퍼 오버플로우
- return address overwrite
- 함수 흐름 제어 탈취
- 원격 서비스 exploit

### 문제 요약
사용자 입력을 제한 없이 읽는 프로그램이 주어지며, 스택에 위치한 버퍼를 초과하는 입력을 통해 반환 주소를 덮을 수 있음  
바이너리 내부에서는 `/bin/sh`를 실행하는 get_shell() 함수가 존재하며, 반환 주소를 해당 함수의 주소로 덮어 쉘을 획득하는 것이 목표임  
원격 서버를 대상으로 공격을 수행해야 하므로, pwntools를 이용해 바이트 단위로 payload를 전송해야 함  

### 코드 분석 포인트
- `scanf("%s", buf)` 사용으로 인해 입력 길이 제한이 없음
- gdb를 활용하여 실제 입력 버퍼 위치 확인
- `[rbp]`에는 Saved RBP(SFP), `[rbp+0x8]`에는 반환 주소가 저장됨
- x86-64 환경에서 반환 주소는 반드시 8바이트로 덮어야 함  
- 올바른 payload를 생성한 후 서버로 보냄

### 접근 과정
1. 디스어세블을 통해 buf의 실제 위치 확인
2. 스택 프레임 구조를 기준으로 반환 주소 위치 계산
3. 반환 주소까지의 오프셋 도출
4. get_shell() 함수의 주소를 디버거로 확인
5. pwntools를 통해 오프셋 + get_shell 주소 형태의 payload 구성
   - 주소는 `p64()`를 이용해 8바이트 리틀 엔디안 바이트열로 변환해야 함 
6. 원격 서버에 payload를 전송하여 쉘 획득


### 어려웠던 점
- `sub rsp, 0x30`을 반환 주소까지의 거리로 오해함
  - 실제로는 `buf -> save RBP -> Return Address` 구조를 고려해야 했음
- Saved RBP(SFP) 개념이 익숙하지 않아 오프셋 계산에서 혼란이 있었음

### 배운 점
- `sub rsp, n`은 지역 변수 공간 크기이지 반환 주소 오프셋이 아님
- 정확한 exploit을 위해서는 스택 프레임 구조를 잘 알아야 함 
- 디스 어셈블에서 `lea rax, [rbp-offset]`은 입력 버퍼 위치를 확인하는 핵심임 

### 쓰인 개념 
- Stack Frame 구조
- Save Frame Pointer (Saved RBP)
- gdb
  - disassemble
- x86-64 calling convention
- pwntools
  - remote, sendline, p64
- bof 취약점 기본 원리 

### 추가 내용
- 64비트 환경에서 표준 스택 프레임을 사용하는 함수라는 `rbp + 8`은 항상 리턴 어드레스임 
