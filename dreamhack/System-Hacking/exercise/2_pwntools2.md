## Dreamhack - pwntools

### 문제 유형
- 시스템 해킹 기초 / pwntools 자동화
- 제한 시간(10초) 내 반복 입력 자동 처리

### 문제 요약
매 라운드마다 10개의 아이템이 섞여 출력됨 (`idx. item` 같은 형식)  
사용자에게 어떤 아이템을 살지 인덱스를 입력받음  
50라운드동안 매번 flag가 있는 인덱스를 정확히 입력해야 함  
전체 소요 시간이 10초 미만이어야 마지막에 flag 파일 내용을 출력  
위의 내용을 구현한 코드 `prob.py`가 주어짐  

## 코드 분석 포인트
- 아이템 출력 형식이 고정되어있음
  - `"{idx}. {item}"
- 입력은 `choice = int(input("> ")`
  - 서버는 아스키 숫자 문자열을 받고 int로 변환
- 오답이면 즉시 종료

### 접근 과정
1. 첫 안내 문구 3줄을 `recvline()`으로 소비
2. 50라운드 반복
   - 라운드 시작에 있는 빈 줄 1개를 `recvline()`으로 소비
   - 아이템 10줄을 읽으면서 위의 아이템 출력 형식을 보고 idx, item을 정확히 추출 (split 이용) 
     - 조건문을 활용하여 flag의 idx를 저장
   - 프롬프트 `b"> "` 이후에 저장한 idx를 전송
3. 50라운드 완료 후 `interactive()`로 최종 출력(플래그)를 터미널에서 확인

### 어려웠던 점
- 출력 라인이 여러 종류라서 `recvline()` 호출이 조금만 어긋나도 에러가 발생함
- `idx, item = ...` 언패킹에서 "X. Y" 형식이 아닌 줄을 읽으면 에러가 발생해서 정확히 어떤 줄을 언제 읽어야 하는지 잡는 게 어려웠음
- recvline() 결과에 `\n`이 포함되어 `item == b"flag"` 비교가 실패했었음
  - strip()을 통해 해결함
- sendlineafter() 함수를 처음 활용해봄

### 배운 점
- pwntools에서 `recvline()`은 기본적으로 개행이 포함된 bytes를 받으므로 비교/파싱 전에 `strip()`으로 정리해야 함
- 출력이 여러 종류의 줄로 구성된 문제에서는 서버 코드 흐름에 맞춰 줄을 정확하게 소비하는 것이 중요함 
- 입력이 `int(input())` 형태라면 서버는 **아스키 숫자 + 개행**을 기대하므로 sendline()이 적절함
- 최종 플래그는 마지막에 출력되므로 `interactive()`를 호출하여 서버가 보내는 결과를 터미널에서 바로 확인해야 함

### 쓰인 개념
- pwntools 기본 통신
  - remote()
  - recvline()
  - sendline()
  - sendlineafter()
  - interactive()
- 출력 포맷 기반 파싱
  - strip()
  - split()
- 언패킹
  - `idx, item = ...` 형태로 split 결과를 변수 2개에 분해
