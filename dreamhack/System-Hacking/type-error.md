# Type Error

## Type Error 
### 자료형 
- **Type Error**
  - 프로그램에서 기대되는 데이터 타입과 실제로 사용된 데이터 타입이 맞지 않을 때 발생하는 오류 
- 자료형
  - 변수의 크기를 규정하고, 그 변수의 용도를 암시함
  - 컴파일러의 동작 : 컴파일러는 자료형을 확인하여 딱 그만큼의 메모리 공간을 할당하며, 모든 연산은 그 할당된 크기 내에서만 이루어짐
- 메모리 크기의 불변성
  - 변수가 한 번 선언되면, 할당된 메모리 크기는 절대 확장되거나 줄어들지 않음
- 오버플로우
  - 변수가 저장할 수 있는 최대 크기를 넘어서는 연산을 할 때 발생함
  - 예시 (1바이트 변수)
    - 최대값 0xff(255) 상태에서 1을 더하면 0x100이 되는 게 아닌, 0x00(0)이 됨
- 대입 시 데이터 유실
  - 변수의 크기보다 더 큰 값을 강제로 대입하려고 할 때 발생함
  - 예시 (4바이트 변수)
    - 대입값 : 0x0123456789abcdef (8바이트 크기)
    - 저장값: 0x89abcdef (하위 4바이트만 남고 상위 값은 버려짐)
- C언어 자료형의 크기와 용도
  | 자료형 | 크기 | 용도 |
  |------|------|------|
  | (signed) char | 1 바이트 | 정수, 문자 |
  | unsigned char | 1 바이트 | 정수 |
  | (signed) short (int) | 2 바이트 | 정수 |
  | unsigned short (int) | 2 바이트 | 정수 |
  | (signed) int | 4 바이트 | 정수 |
  | unsigned int | 4 바이트 | 정수 |
  | size_t | 32bit: 4 바이트<br>64bit: 8 바이트 | 부호 없는 정수 |
  | (signed) long | 32bit: 4 바이트<br>64bit: 8 바이트 | 정수 |
  | unsigned long | 32bit: 4 바이트<br>64bit: 8 바이트 | 정수 |
  | (signed) long long | 8 바이트 | 정수 |
  | unsigned long long | 8 바이트 | 정수 |
  | float | 4 바이트 | 실수 |
  | double | 8 바이트 | 실수 |
  |   Type * | 32bit: 4 바이트<br>64bit: 8 바이트 | 주소 |
  - 같은 자료형이라도 운영체제에 따라 크기가 달라질 수 있음 

### Out of Range 
- 데이터 유실
  - 변수에 어떤 값을 대입할 때, 그 값이 변수에 저장될 수 있는 범위를 벗어나면, 저장할 수 있는 만큼만 저장하고 나머지는 모두 유실됨
- 부호 반전과 값의 왜곡
  - 같은 메모리 값을 두고 자료형에 따라 다르게 해석하기 때문에 발생
  - ex. `int` & `unsigned int`
  - 양수로만 쓰일 값에 반드시 `unsigned`를 붙이는 습관을 들여야 함
- 버퍼 오버플로우
  - 잘못된 자료형의 사용이 스택 버퍼 오버플로우로 이어질 수 있음 

### 타입 오버플로우와 언더플로우
- **Type Overflow/Underflow** : 변수의 값이 연산 중에 자료형의 범위를 벗어나면, 갑자기 크기가 작아지거나 커지는 현상
  - 정수 자료형을 대상으로 발생 : Integer Overflow/Underflow
- **Overflow** : 최대값보다 커지면, 최소값으로 돌아감
  - 예시 : unsigned 1바이트 (0 ~ 255)
    - 연산 : 255 + 1
    - 결과 : 256이 되어야 하지만, 비트가 1 0000 0000 (9자리)이 되면서 맨 앞의 1이 잘려 나감
    - 최종값 : 0 (최소값)
  - 예시 : signed 1바이트 (-128 ~ +127)
    - 연산 : 127 + 1
    - 결과 : 2진수 0111 1111(127)에 1을 더하면 1000 0000(-128)이 됨
    - 최종값 : -128 (최소값)
- **Underflow** : 최소값보다 작아지면, 최대값으로 돌아감
  - 예시 : unsigned 1바이트 (0 ~ 255)
    - 연산 : 0 - 1
    - 결과 : 연산 결과 1111 1111
    - 최종값 : 255 (최댓값)
  - 예시 : signed 1바이트 (-128 ~ +127)
    - 연산 : -128 - 1
    - 결과 : 1000 0000 에서 1을 빼면 0111 1111이 됨
    - 최종값 : 127 (최댓값) 
    
