# Linux Fundamentals

## Linux Basic Commands
- `id` : 현재 유저의 유저 ID와 해당 유저가 속해있는 그룹 ID를 출력
  - 리눅스는 권한을 기반으로 파일을 읽고 쓰고 실행할 수 있기 때문에 주로 자신이 해당하는 권한을 가지고 있는지 확인하기 위해 사용
- `pwd` (Print Working Directory) : 현재 작업 중인 디렉토리의 경로를 출력
- `ls` (List) : 디렉토리의 내용을 출력
  - `ls ..` : 상위 디렉토리의 파일 목록 출력
  > 보안 관점 : 디렉터리 권한 / 파일 유출 검사
- `cd` (Change Directory) : 작업 중인 디렉토리 변경
  - 절대 경로 : 루트 디렉토리 /를 시작으로 모든 경로를 적어서 표현하는 경로
  - 상대 경로 : 현재 디렉토리를 기준으로 상위 디렉토리 또는 하위 디렉토리로 뻗어 나가는 경로
    - ex. `cd..` : 현재 디렉토리에서 부모 디렉토리로 이동
    - 현재 디렉토리가 `/home/user/`일 때 `cd..`을 실행하면 `/home`으로 이동
- `mkdir` (Make Directory) : 디렉토리 생성
  - ex. `mkdir new_dir`명렁어로 new_dir 디렉토리를 생성하면, 현재 디렉토리에 새롭게 추가됨
- `touch` : 비어 있는 새로운 파일을 만드는 데 사용
  - 앞서 생성한 new_dir 디렉토리로 이동 후 `ls -l`을 실행해보면 아무런 파일도 존재하지 않음
  - 이때 `touch new_file` 명령어를 실행한 후 `ls -l`을 실행하면, new_file 파일이 생성됨
- `mv` (Move) : 파일이나 디렉토리의 위치를 옮기거나 이름을 변경할 때 사용
  - ex. `mv new_file old_file` : new_file을 old_file로 변경
  - ex. `mv old_file ..` : old_file을 상위 디렉토리로 이동
- `rm` (Remove) : 파일을 삭제하는 명령어
  - 디렉터리는 `rm`명령어로 삭제되지 않음
  - `rm -r` : 디렉토리와 그 안의 모든 파일을 재귀적으로 삭제
- `cat` : 파일의 내용 출력
  - 형식 : `cat 파일경로` ex. cat /etc/passwd
- `file` : 파일의 유형 출력
  - 형식 : `file 파일경로`
- `echo` : 셸에 유저가 입력한 텍스트를 출력
  - `echo` 명령문 끝에 `> 파일명`을 이어붙여 실행하면 `파일명`을 이름으로 가지는 파일을 생성하고, `echo` 뒤에 입력한 내용을 파일 내용으로 저장
- `cp` : 파일을 복사하는 명령어
  - 디렉토리를 복사할 때는 플래그를 붙인 형태인 `cp -r` 사용
  - ex. `cp hello world` : hello 파일을 world라는 이름으로 복사
- `grep` : 전체에서 특정 문자열을 찾을 때 사용
  - 형식 : `grep 문자열 파일`
  - 문자열이 포함된 행 전체를 출력
- `man` : 특정 명렁어의 매뉴얼을 보여주는 명령어
  - 매뉴얼은 명렁어 사용법, 옵션, 예제 등 유용한 정보를 담고 있음
- `curl` (client URL) : 서버에 데이터를 보내거나 서버로부터 데이터를 받는 전송 명령어
  - 형식 : `curl [옵션] URL`
    - 옵션 1) `-o file` : 전송 받은 데이터를 파일에 저장
    - 옵션 2) `-i` : 결과 값에 HTTP 응답 헤더를 포함
    - 옵션 3) `X "method"` : HTTP 요청 메소드를 지정
    - 옵션 4) `-d "key=value"` : HTTP POST 메소드로 데이터를 전송
  - HTTP, HTTPS, FTP 등 다양한 프로토콜 지원
  - curl을 이용한 명령어 실행 결과 전송
    - `curl`은 HTTP 요청을 통해 데이터를 서버로 전송할 수 있음
    - 쉘에서는 명령어 실행 결과를 문자열로 치환하는 기능이 있음
    - 이 두 기능을 결합하면 명령어 실행 결과를 HTTP 요청의 body에 포함시켜 전송 가능
      - 이때 curl이 명령을 실행하는 것이 아니라, 쉘이 먼저 명령을 실행하고, 그 결과를 curl에 전송
- **와일드카드(wildcards)** : 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자
  - **?** :
    - a-z, 0-9 범위 내 임의의 1개 문자로 대체
    - ex. 현재 디렉토리에 파일이 `file1.txt  file2.txt  fileA.txt  file10.txt` 이렇게 있다고 가정
      - `ls file?.txt` 실행
      - 결과 : `file1.txt  file2.txt  fileA.txt`
  - __*__ :
    - a-z, 0-9 범위 내 임의의 0개 이상 문자로 대체
    - ex. 현재 디렉토리에 파일이 `file1.txt  file2.txt  fileA.txt  file10.txt` 이렇게 있다고 가정
      - `ls file*.txt` 실행
      - 결과 : `file1.txt  file2.txt  fileA.txt  file10.txt`
  - **[]**
    - [문자1-문자2] 또는 [문자1, 문자2, ...] 형태로 범위를 지정
    - 범위 내 모든 문자로 대체 가능
    - ex. 현재 디렉토리에 파일이 `log1.txt  log2.txt  log3.txt  logA.txt` 이렇게 있다고 가정
      - `ls log[1-3].txt` 실행
      - 결과 : log1.txt  log2.txt  log3.txt`
      - `ls log[13A].txt` 실행
      - 결과 : `log1.txt  log3.txt  logA.txt`
- **리다이렉션(redirection)** : 모니터에 나타나는 표준 출력 또는 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업
  - 어떤 명령어의 결과를 파일로 저장하거나, 다른 명령어의 입력으로 전달하는 형태로 리다이렉션
  - **명령어 > 파일** : 명령어 표준 출력을 파일로 변경
    - 파일이 없으면 새로 만들고, 있으면 덮어씀
    - 예시 : `ls test[0-9]`명령어 결과를 world 파일에 씀
      ```
      user@user-VirtualBox:~/new_dir$ ls test[0-9]
      test1  test2  test3
      user@user-VirtualBox:~/new_dir$ ls test[0-9] > world
      user@user-VirtualBox:~/new_dir$ cat world
      test1
      test2
      test3
      user@user-VirtualBox:~/new_dir$
      ```
  - **명령어 >> 파일** : 명령어 표준 출력을 파일로 변경
    - 파일이 없으며 새로 만들고, 있으면 이어서 씀
    - 예시 : `cat hello`명령어 결과를 world 파일에 씀
      ```
      user@user-VirtualBox:~/new_dir$ cat hello
      hello
      user@user-VirtualBox:~/new_dir$ cat hello >> world
      user@user-VirtualBox:~/new_dir$ cat world
      test1
      test2
      test3
      hello
      user@user-VirtualBox:~/new_dir$
      ```
  - **명령어 < 파일** : 명령어 표준 입력을 파일로 변경
    - 파일로부터 표준 입력을 받아 명령어 수행
    - 예시 :
      ```
      user@user-VirtualBox:~/new_dir$ cat world
      test1
      test2
      test3
      hello
      user@user-VirtualBox:~/new_dir$ grep test < world
      test1
      test2
      test3
      user@user-VirtualBox:~/new_dir$
      ```
  - **파이프(pipe)** : 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용
    - 파이프틑 문자 `|`로 표현
    - ex. `ls -l`명령 결과에서 hello가 포함된 행을 찾아 출력 : `ls -l | grep hello`

## 권한
### 유저(User)와 그룹(Group)
- 유저 : 이름과 고유한 사용자 ID(UID)를 가지고 있음
- 그룹 : 여러 유저가 속할 수 있는 그룹으로, 그룹 이름과 고유한 그룹 ID(GID)를 가지고 있음
- 파일이나 디렉토리에 유저가 접근하면 유저의 UID와 해당 유저가 속한 그룹의 GID를 확인하여 정당한 권한을 가지고 있는지를 판단해 접근을 제어
- `cat 유저정보텍스트파일` : 각 사용자의 이름, 사용자 ID, 속해있는 그룹 ID 등의 정보 포함
- `cat 그룹정보텍스트파일` : 각 그룹의 이름, 그룹 ID, 그룹에 속한 유저 목록 등의 정보 포함
### 파일 및 디렉토리 권한
- 각 파일과 디렉토리는 소유자(owner)와 소유 그룹(group)을 가지고 있음
  - 소유자 : 파일 또는 디렉토리의 권한을 수정할 수 있는 능력을 가짐
    - 소유자 또는 소유 그룹에 포함된 유저가 해당 파일 또는 디렉토리에 대해서 얼마만큼 접근 권한을 가질 것인지 설정 가능
      - **읽기(Read)** : 파일 또는 디렉토리의 내용을 볼 수 있게 허용
      - **쓰기(Write)** : 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용
      - **실행(Execute)** : 파일이 프로그램인 경우 실행할 수 있게 허용 / 디렉토리의 내용에 접근할 수 있도록 허용
- 파일이나 디렉토리의 권한을 보기 위해 `ls -l` 사용
  - ex. `drwxrwxr-x 2 user user 4096 12월 2 13:38 dir`
    - 첫 번째 열 : 권한 플래그 `drwxrwxr-x`
      - d rwx rwx r-x
        - 첫 번째 문자 : 파일의 타입 (`d` 디렉토리, `-` 일반 파일, `l` 바로가기)
        - 다음 문자들은 권한 플래그 (소유자의 권한, 소유 그룹에 포함된 유저들의 권한, 나머지 유저들의 권한)
        - r : 읽기 권한 / w : 쓰기 권한 / x : 실행 권한
        - 권한 나타내는 3개 문자를 2진수 또는 10진수로 표현 가능 (rwx = 111, rw- = 110)
    - 세 번째 열 : 소유자 `user`
    - 네 번째 열 : 소유 그룹 `user`
  - ex. -rwxrw-r-- 1 user user 13 12월 2 13:08 world`
    - 소유자 `user`, 소유 그룹 `user`
    - 파일 타입을 나타내는 첫 문자가 `-`이므로 world는 일반 파일
    - 소유자 권한 프래그 = rwx : `user`유저는 world 파일을 읽고 쓰고 실행 가능
    - 소유 그룹 권한 플래그 = rw- : `user`그룹에 속한 유저들은 world 파일을 읽고 쓸 수 있음. 실행 X
    - 나머지 유저 플래그 = r-- : 나머지 유저들은 world 파일을 읽을 수만 있음. 쓰기 X 실행 X
- `chmod` : 파일 권한을 변경하는 명령어
  - `root`유저 또는 파일의 소유자만 실행 가능
    - root 유저 : 리눅스에서 모든 권한을 가진 최고 관리자 (권한 검사 안 해도 모든 파일 읽기, 쓰기, 실행 전부 가능)
  - 형식 : `chmod 권한 파일명`
  - ex. 기존 권한 : ---------- -> `chmod 774 hello` -> -rwxrwxr--
  - `chmod g+(rwx) 파일명` : 소유 그룹에 실행 권한 부여
  - `chmod g-(rwx) 파일명` : 소유 그룹에 실행 권한 제거
- `chown` : 파일 소유자 또는 소유 그룹을 변경하는 명령어
  - `root`유저만 실행 가능
    - 형식 : `chown 사용자명[.그룹명] 파일명`
    - 소유 그룹만 변경하고 싶은 경우 `chgrp`명령어 사용
    - ex. `sudo chown root hello` : 소유자를 user에서 root로 변경
      - 명령어를 root 권한으로 실행하려면 맨 앞에 `sudo`를 붙여
### 특수권한
- **setuid** : 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행됨
  - 일반적으로 프로그램은 실행한 사람의 권한으로 실행됨
  - 일반 유저가 실행하지만 일부 작업만 root 권한이 필요한 경우 setuid 사용
  - 소유자의 실행 권한에 `x` 대신 `s`로 나타냄
    - 's' = setuid 설정 + 실행 가능
    - `S` = setuid 설정 + 실행 불가
- **setgid** : 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행됨
  - 소유 그룹의 실행 권한에 `x` 대신 `s`로 나타냄
- **sticky bit** : 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제할 수 없음
  - 주로 공용 디렉토리에 사용
  - 쓰기 권한이 있어도 남의 파일은 삭제 못하게 하는 것 (누구나 글 작성 가능, but 삭제는 자기 글만 가능)
  - 일반 사용자의 실행 권한에 `x` 대신 `t`로 나타냄
    - 실행 권한이 없는 경우 `T`
- **특수 권한 지정** : 권한 플래그 맨 앞에 숫자를 붙여 나타냄
  - setuid = 4
  - setgid = 2
  - sticky bit = 1
- `chmod 권한 파일명`
  - 권한 : 특수비트 | 소유자 | 그룹 | 기타
  - ex. `chmod 4754 hello`
    - (1) 맨 앞자리 `4` : setuid 켜기
    - (2) 나머지 3자리 : 기존 rwx 권한
      - 7 = rwx, 5 = r-x, 4 = r-- -> `-rwxr-xr--`
    - 소유자 실행 자리에 setuid가 들어왔으므로 `-rwsr-xr--`
  - setuid만 설정하는 경우 : `chmod u+s [파일명]`
  - setgid만 설정하는 경우 : `chmod g+s [파일명]`
  - sticky bit만 설정하는 경우 : `chmod o+t [파일명]`

 ## 디렉토리 구조
 ### 디렉토리 구조
 - **루트 디렉토리 `/`** : 리눅스의 최상위 디렉토리
   - 절대 경로 : `/`
   - `cd /; ls -l` 또는 `ls -l /`을 실행하면 루트 디렉토리에 존재하는 파일과 디렉토리들을 볼 수 있음
- 주요 디렉토리
  - `bin` : 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리
    - 명령어 그 자체가 들어있음
    - `ls` : 실제로는 `/bin/ls`가 실행되는 것 
  - `boot`: 시스템 부팅에 필요한 파일들을 담고있는 디렉토리
  - `dev` : 장치를 파일처럼 다루기 위한 디렉토리 (디스크, 키보드, 터미널 같은 하드웨어, 가상 장치들이 파일로 존재)
    - `/dev/null` : 모든 입력을 버림
    - `/dev/random/`, `/dev/urandom` : 랜덤 생성
  - `/etc` : 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리
    - 비유 : 리눅스가 어떻게 동작할지 적혀 있는 설정 노트
    - 유저 정보, 네트워크 설정, 서비스 설정, 보안 설정 등 포함
    - `/etc/passwd`, `/etc/shadow`, `/etc/group`, `/etc/hostname` (대부분 텍스트 파일)
    - 일반 유저가 수정할 수 없음 -> `sudo` 필요
  - `/home` : 각 일반 유저들의 홈 디렉토리를 담고 있는 디렉토리
    - 리눅스에는 여러 사용자가 동시에 존재할 수 있음. 각 사요자는 `/home/username` 디렉토리를 가짐
    - root의 홈 디렉토리는 `/root`
  - `/lib` : 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리
    - 라이브러리 = 여러 프로그램이 함께 쓰는 기능 묶음
  - `/opt` : 소프트웨어 패키지들을 담는 디렉토리
  - `/proc` : 리눅스 커널 자원 및 실행 중인 프로세스 정보를 파일 형태로 제공하는 가상 파일 시스템 디렉토리
    - 커널이 시스템 및 프로세스 상태를 실시간으로 생성하여 보여줌 (실제 디스크에 저장되는 파일이 아님)
    - `/proc/[PID]/` 디렉토리를 통해 각 프로세스의 정보 확인 가능
      - ex. `cat /proc/1023/cmdline` : PID 1023 프로세스가 어떤 명령으로 실행되었는지 확인
    - 커널 : 하드웨어를 직접 관리하는 운영체제의 핵심
      - 프로그램은 커널을 통해서만 CPU, 메모리, 디스크에 접근 가능 
  - `/sbin` : root 유저가 사용할 수 있는 명령어나 프로그램을 가지고 있는 디렉토리
  - `/tmp` : 유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리
    - 모든 유저가 사용 가능 (sticky bit 설정됨)
    - 임시성 (재부팅 시 삭제되는 경우가 많음) 
  - `/usr` : 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리
  - `/var` : 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리
    - `/var/log` : 시스템 로그, 로그인 기록, 에러 기록 등 존재 -> 보안 분석에서 매우 중요
      - 로그 : 시스템이나 프로그램이 자기 행동을 기록해둔 것
        - 사용자 행동, 에러, 서비스 상태 등이 자동으로 기록
      - ex. `Failed password for user from 192.168.0.10` : 로그인 실패 로그

## 추가 내용
### HTTP 통신
- 기본 구조 : [요청(Request)] -> [응답(Response)]
- 요청 : 요청라인 | 요청헤더 | (빈 줄) | 요청바디
  - 요청 메서드 : GET (정보 얻음) & POST (정보 보냄)
  - 요청라인 : 서버에게 무엇을 해달라고 요청하는지 한 줄로 적은 것
    - 형식 : METHOD PATH HTTP/VERSION
    - ex. GET /index.html HTTP/1.1 -> 이 파일을 HTTP로 가져와라
    - ex. POST /login HTTP/1.1 -> /login 경로로 데이터를 보낼 거다
  - 헤더 : 부가정보 (형식, 데이터 길이 등)
  - 빈 줄 : 헤더와 바디 사이의 경계선
  - 바디 : 진짜 내용
  - 실제 HTTP 형태 :
    ```
    POST /login HTTP/1.1
    Host: example.com
    Content-Type: application/x-www-form-urlencoded
      
    id=admin&pw=1234
    ```
- 응답 : 상태라인 | 응답헤더 | (빈 줄) | 응답바디
  - 상태라인 : 서버가 요청 결과가 어땠는지를 알려주는 첫 줄
  - 형식 : HTTP/VERSION STATUS_CODE STATUS_MESSAGE
    - ex. HTTP/1.1 200 OK
      - `HTTP/1.1` : HTTP 1.1로 응답
      - `200` : 성공
      - `OK` : 성공했다는 설명
    - ex. HTTP/1.1 404 Not Found : 없다는 의미
  - 실제 예시 :
    ```
    HTTP/1.1 200 OK
    Content-Type: text/html
    Set-Cookie: session=abcd
      
    <html>...</html>
    ```
- 브라우저는 자동으로 헤더 숨기고 쿠키 관리하고 화면만 보여줌
  - 쿠키 : 서버가 클라이언트에게 저장하라고 주는 작은 데이터 (비유 : 클라이언트가 들고 다니는 신분증)
    - 저장 위치 : 브라우저
    - 형태 : key=value
    - 자동으로 요청에 포함됨
    - 실제 형태 :
      - 서버 -> 클라이언트 (응답) : Set-Cookie: sessionid=ABC123
      - 클라이언트 -> 서버 (다음 요청) : Cookie: sessionid=ABC123
  - 세션 : 서버에 저장되는 사용자 상태 정보
    - 저장 위치 : 서버 메모리 / DB
    - 로그인 정보, 권한 정보 등
    - 클라이언트는 세션 내용을 모르고, 세션 자체는 서버에만 있음
  - 로그인 전체 흐름
    - (1) 로그인 요청
      ```
      POST /login
      id=admin&pw=1234
      ```
    - (2) 서버
      - 로그인 성공, 세션 생성, 세션 ID 발급
    - (3) 서버 응답
      `set-Cookie: sessionid=ABC123`
    - (4) 이후 모든 요청
      `Cookie : sessionid=ABC123`
    - (5) 서버는
      - ABC123 -> admin이네
  > 보안과의 연계성 : 
  > HTTP는 기본적으로 상태를 저장하지 않기 때문에, 인증 상태 유지를 위해 쿠키와 세션을 사용함. 
  > 쿠키에 저장된 세션ID가 노출되면, 다른 사용자가 로그인된 사용자처럼 동작할 수 있음. 
  > 따라서 쿠키 보호는 웹 보안에서 매우 중요함
- `curl`은 요청/응답을 그대로 보여줌
 
  
