# CS Basics
Computer science fundamentals for DreamHack Beginners.

## Data representation

### Bit & Byte
- **Bit** : 0 또는 1의 값을 가지는 데이터의 최소 단위
- **Byte** : 8개의 비트로 구성된 더 큰 단위, 메모리에 저장되는 최소단위

### MSB & LSB
- **MSB**(Most Significant Bit)
  - 가장 왼쪽에 있는 비트 -> 숫자 크기에 가장 큰 영향
  - 부호가 있는 데이터의 경우 : MSB = 부호 비트
    - 0 : 양수 / 1 : 음수
- **LSB**(Least Significant Bit)
  - 가장 오른쪽에 있는 비트

### Byte Ordering
- **Big Endian**
  - 가장 상위 바이트가 낮은 메모리 주소에 저장됨
  - 사용 예 : 네트워크 상에서 데이터를 전송할 때, SPARC CPU
- **Little Endian**
  - 가장 하위 바이트가 낮은 메모리 주소에 저장 -> 출력 시 높은 주소부터 읽어와서 원래 값 그대로 출
  - 사용 예 : Intel의 x86, x86-64 CPU
- **Example** : 0x01234567
  - 빅엔디안 : 0x01 | 0x23 | 0x45 | 0x67
  - 리틀엔디안 : 0x67 | 0x45 | 0x23 | 0x01
- 문자열을 메모리에 저장할 때는 바이트 오더링을 고려하지 않음

### Bit 연산
- **논리 연산** : 참 또는 거짓 값으로 연산을 수행하고 결과로 참 또는 거짓을 반환
  - x || y : 둘 중 하나라도 참이면 결과는 참
  - x && y : 둘 다 참이면 결과는 참
  - !x : 참이면 결과는 거짓, 거짓이면 결과는 참
- **비트 연산** : 비트 단위로 논리 연산을 수행
  - x | y : 두 비트 중 하나라도 1이면 결과는 1
  - x & y : 두 비트 모두 1이면 결과는 1
  - x ^ y : 두 비트가 같으면 결과는 0, 다르면 결과는 1
  - ~x : 비트가 0이면 결과는 1, 1이면 결과는 0 (비트 반전)
- **시프트 연산자** : 비트를 특정 값만큼 왼쪽 또는 오른쪽으로 이동
  - x << n : 비트를 n만큼 왼쪽으로 이동
    - 오른쪽 빈 칸은 0으로 채움
    - x << n == x * $2^n$
  - x >> n (산술 시프트) : 비트를 n만큼 오른쪽으로 이동
    - 왼쪽 빈 칸은 MSB와 동일한 비트 값으로 채움
    - x << n == x / $2^n$
  - X >>> n (논리 시프트) : 비트를 n만큼 오른쪽으로 이동
    - 왼쪽 빈 칸은 모두 0으로 채움 -> 음수는 부호가 유지되지 않음
  - 활용 : AND 연산과 시프트 연산을 활용하여 특정 비트 / 바이트 가져오기
    - ex. 0x12345678에서 특정 비트만 가져오기
    - 하위 1바이트 가져오기 : 0x000000FF와 AND 연산
      - 0x12345678 & 0x000000FF = 0x00000078 (0000 0000 0000 0000 0000 0000 0111 1000)
    - 상위 1바이트 가져오기 : 24번 우측으로 논리시프트 / 24번 우측으로 산술 시프트 후 0x000000FF와 AND 연산
      - 0x12345678 >>> 24 = 0x00000012 (0000 0000 0000 0000 0000 0000 0001 0010)
      - 0x12345678 >> 24 & 0x000000FF = 0x00000012 (0000 0000 0000 0000 0000 0000 0001 0010)
    - 상위에서 두 번째 바이트 가져오기 : 16번 우측으로 시프트 후 0x000000FF와 AND 연산
      - 0x12345678 >> 16 & 0x000000FF = 0x00000034 (0000 0000 0000 0000 0000 0000 0011 0100)
    - 하위 1바이트의 상위 4비트 가져오기 : 4번 우측으로 시프트 후 0x0000000F와 AND 연산
      - 0x12345678 >> 4 & 0x0000000F = 0x00000007 (0000 0000 0000 0000 0000 0000 0000 0111)
     
### Encoding, Decoding
- **Encoding** : 데이터를 특정한 형식으로 변환하는 것
- **Decoding** : 인코딩된 데이터를 원래의 값으로 변환하는

### ASCII Code
- 문자를 숫자로 변환하는 문자 인코딩의 표준
- 알파벳 대소문자, 숫자, 특수 문자, 제어 문자 포함
- 아스키 문자 1개는 1바이트 -> 7비트로 문자 표현 / 1비트로 오류 체크
- $2^7$ = 128가지의 문자 표현 가능

### Unicode
- 전세계 모든 언어의 문자에 고유한 번호를 부여하는 국제 표준 코드
- 최대 32비트로 문자 1개를 표현

### URL Encoding
- 웹 브라우저로부터 받은 URL 문자열을 유효한 형식으로 변환하는 것
- URL은 알파벳 대소문자, 숫자, 일부 특수 문자만 포함 가능
- 인코딩이 필요한 특수문자 : :/?#[]@!$'()*+,;=%공백
- 인코딩 방법 : % 기호 뒤에 해당 문자의 아스키 코드 16진수 값을 붙인다.
- ex. 공백 -> %20
- **Example** : Welcome, Dreamhack Beginners! :)
  - URL 인코딩 결과 : Welcome%2C%20Dreamhack%20Beginners%21%20%3A%29

### Base64 Encoding
- 이진 데이터를 아스키 문자로 구성된 텍스트로 변환하는 인코딩 방식 : [이진 데이터] → Base64 → [문자 데이터]
  - 이진 데이터 : 0과 1의 조합으로 이루어진 데이터(문자로 해석하지 않음)
    - ex. 이미지 파일, 실행 파일
- 이진 데이터를 그대로 포함할 수 없이 텍스트만 허용되는 환경에서 이진 데이터를 텍스트 형식으로 나타내기 위해 사용
- 64개의 아스키 문자가 인코딩에 사용됨
  - ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
